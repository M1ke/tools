<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>JWT Parser and Editor</title>
  <style>
      * {
          margin: 0;
          padding: 0;
          box-sizing: border-box;
      }

      body {
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
          min-height: 100vh;
          padding: 20px;
      }

      .container {
          max-width: 1200px;
          margin: 0 auto;
          background: white;
          border-radius: 12px;
          padding: 30px;
          box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      }

      h1 {
          color: #333;
          margin-bottom: 10px;
          font-size: 28px;
      }

      .subtitle {
          color: #666;
          margin-bottom: 30px;
          font-size: 14px;
      }

      .section {
          margin-bottom: 25px;
      }

      label {
          display: block;
          font-weight: 600;
          color: #444;
          margin-bottom: 8px;
          font-size: 14px;
      }

      textarea {
          width: 100%;
          padding: 12px;
          border: 2px solid #e0e0e0;
          border-radius: 8px;
          font-family: 'Courier New', monospace;
          font-size: 13px;
          resize: vertical;
          transition: border-color 0.3s;
      }

      textarea:focus {
          outline: none;
          border-color: #667eea;
      }

      #input {
          min-height: 100px;
      }

      #header, #payload, #signature {
          min-height: 150px;
          background: #f8f9fa;
      }

      #output {
          min-height: 100px;
          background: #e8f5e9;
      }

      .hidden {
          display: none;
      }

      .error {
          color: #d32f2f;
          font-size: 13px;
          margin-top: 5px;
      }

      .grid {
          display: grid;
          grid-template-columns: 1fr 1fr 1fr;
          gap: 20px;
      }

      @media (max-width: 768px) {
          .grid {
              grid-template-columns: 1fr;
          }
      }
  </style>
</head>
<body>
<div class="container">
  <h1>JWT Parser and Editor</h1>
  <p class="subtitle">Paste a JWT to decode, edit the parts, and see the reconstructed token</p>

  <div class="section">
    <label for="input">1. Paste JWT here:</label>
    <textarea id="input" placeholder="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"></textarea>
    <div id="inputError" class="error hidden"></div>
  </div>

  <div id="decodedSection" class="hidden">
    <div class="grid">
      <div class="section">
        <label for="header">2. Header (decoded):</label>
        <textarea id="header"></textarea>
        <div id="headerError" class="error hidden"></div>
      </div>

      <div class="section">
        <label for="payload">3. Payload (decoded):</label>
        <textarea id="payload"></textarea>
        <div id="payloadError" class="error hidden"></div>
      </div>

      <div class="section">
        <label for="signature">4. Signature:</label>
        <textarea id="signature"></textarea>
      </div>
    </div>

    <p>Edit any of the above fields to reconstruct the token. If setting the header "alg" field to a different value, edit the signature (this page won't sign the token for you). If using "alg=none" then clear the signature textarea.</p>

    <div class="section">
      <label for="output">5. Reconstructed JWT:</label>
      <textarea id="output" readonly></textarea>
    </div>
  </div>
</div>

<script>
	const inputEl = document.getElementById('input');
	const headerEl = document.getElementById('header');
	const payloadEl = document.getElementById('payload');
	const signatureEl = document.getElementById('signature');
	const outputEl = document.getElementById('output');
	const decodedSection = document.getElementById('decodedSection');
	const inputError = document.getElementById('inputError');
	const headerError = document.getElementById('headerError');
	const payloadError = document.getElementById('payloadError');

	function base64UrlDecode(str) {
		str = str.replace(/-/g, '+').replace(/_/g, '/');
		while (str.length % 4) {
			str += '=';
		}
		return decodeURIComponent(atob(str).split('').map(c => {
			return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
		}).join(''));
	}

	function base64UrlEncode(str) {
		return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, (match, p1) => {
			return String.fromCharCode('0x' + p1);
		})).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
	}

	function parseJWT(jwt) {
		const parts = jwt.trim().split('.');
		if (parts.length !== 3) {
			throw new Error('Invalid JWT format. Expected 3 parts separated by dots.');
		}

		try {
			const header = base64UrlDecode(parts[0]);
			const payload = base64UrlDecode(parts[1]);
			const signature = parts[2];

			const headerJson = JSON.parse(header);
			const payloadJson = JSON.parse(payload);

			return {
				header: JSON.stringify(headerJson, null, 2),
				payload: JSON.stringify(payloadJson, null, 2),
				signature: signature
			};
		} catch (e) {
			throw new Error('Failed to decode JWT: ' + e.message);
		}
	}

	function reconstructJWT() {
		try {
			headerError.classList.add('hidden');
			payloadError.classList.add('hidden');

			const headerJson = JSON.parse(headerEl.value);
			const payloadJson = JSON.parse(payloadEl.value);

			const encodedHeader = base64UrlEncode(JSON.stringify(headerJson));
			const encodedPayload = base64UrlEncode(JSON.stringify(payloadJson));
			const sig = signatureEl.value.trim();

			outputEl.value = `${encodedHeader}.${encodedPayload}.${sig}`;
		} catch (e) {
			if (e.message.includes('header') || headerEl.value.trim()) {
				try {
					JSON.parse(headerEl.value);
				} catch {
					headerError.textContent = 'Invalid JSON in header';
					headerError.classList.remove('hidden');
				}
			}
			if (e.message.includes('payload') || payloadEl.value.trim()) {
				try {
					JSON.parse(payloadEl.value);
				} catch {
					payloadError.textContent = 'Invalid JSON in payload';
					payloadError.classList.remove('hidden');
				}
			}
		}
	}

	inputEl.addEventListener('input', () => {
		const jwt = inputEl.value.trim();

		if (!jwt) {
			decodedSection.classList.add('hidden');
			inputError.classList.add('hidden');
			return;
		}

		try {
			const decoded = parseJWT(jwt);
			headerEl.value = decoded.header;
			payloadEl.value = decoded.payload;
			signatureEl.value = decoded.signature;

			decodedSection.classList.remove('hidden');
			inputError.classList.add('hidden');

			reconstructJWT();
		} catch (e) {
			inputError.textContent = e.message;
			inputError.classList.remove('hidden');
			decodedSection.classList.add('hidden');
		}
	});

	headerEl.addEventListener('input', reconstructJWT);
	payloadEl.addEventListener('input', reconstructJWT);
	signatureEl.addEventListener('input', reconstructJWT);
</script>
</body>
</html>
