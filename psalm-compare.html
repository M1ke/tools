<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Psalm Array Type Comparator</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
<div class="container">
  <a href="index.html" class="home-link">Back to Home</a>
  <h1>Psalm Array Type Comparator</h1>
  <p class="subtitle">Compare two array type definitions from Psalm error messages.</p>

  <div class="section">
    <label for="input">Psalm Error Message:</label>
    <textarea id="input" placeholder="Paste Psalm error message containing two array{} type definitions"></textarea>
  </div>

  <div class="section">
    <label for="output">Type Differences:</label>
    <textarea id="output" readonly></textarea>
  </div>

  <h2>Example</h2>
  <p>Input:</p>
  <pre>The type 'array{adm: bool, ctd: string, eml: string, exp: int, img: string, lgo: null|string, llid: int|null, lnm: null|string, name: string, role: array<array-key, mixed>, uid: int}' is more general than the declared return type 'array{adm: bool, ctd: string, eml: string, exp: int, img: string, lgo: null|string, llid: int|null, lnm: null|string, name: string, role: list<string>, uid: int}'</pre>
  <p><em>All processing for this is done in your browser; no data is sent to any remote server</em></p>
</div>

<script>
	const inputEl = document.getElementById('input');
	const outputEl = document.getElementById('output');

	function extractArrayShapes(text) {
		const shapes = [];
		let pos = 0;

		while (pos < text.length) {
			const arrayStart = text.indexOf('array{', pos);
			if (arrayStart === -1) break;

			let depth = 0;
			let i = arrayStart + 5;
			let inShape = false;

			for (; i < text.length; i++) {
				if (text[i] === '{') {
					depth++;
					inShape = true;
				} else if (text[i] === '}') {
					depth--;
					if (depth === 0) {
						break;
					}
				}
			}

			if (inShape && i < text.length) {
				const content = text.substring(arrayStart + 6, i);
				shapes.push(content);
				pos = i + 1;
			} else {
				break;
			}
		}

		return shapes;
	}

	function parseArrayShape(content) {
		const result = {};
		let pos = 0;

		while (pos < content.length) {
			pos = skipWhitespace(content, pos);
			if (pos >= content.length) break;

			const keyEnd = content.indexOf(':', pos);
			if (keyEnd === -1) break;

			const key = content.substring(pos, keyEnd).trim();
			pos = keyEnd + 1;
			pos = skipWhitespace(content, pos);

			const typeEnd = findTypeEnd(content, pos);
			const type = content.substring(pos, typeEnd).trim();

			result[key] = type;
			pos = typeEnd;

			pos = skipWhitespace(content, pos);
			if (pos < content.length && content[pos] === ',') {
				pos++;
			}
		}

		return result;
	}

	function skipWhitespace(str, pos) {
		while (pos < str.length && /\s/.test(str[pos])) {
			pos++;
		}
		return pos;
	}

	function findTypeEnd(content, start) {
		let depth = 0;
		let angleDepth = 0;
		let pos = start;

		while (pos < content.length) {
			const char = content[pos];

			if (char === '{') {
				depth++;
			} else if (char === '}') {
				if (depth === 0) break;
				depth--;
			} else if (char === '<') {
				angleDepth++;
			} else if (char === '>') {
				angleDepth--;
			} else if (char === ',' && depth === 0 && angleDepth === 0) {
				break;
			}

			pos++;
		}

		return pos;
	}

	function extractNestedArrayShape(typeStr) {
		// Check if the type contains a nested array{...} within a generic
		// e.g., "list<array{...}>" or "array<int, array{...}>"
		// NOT just "array{...}" by itself

		const arrayShapeStart = typeStr.indexOf('array{');
		if (arrayShapeStart === -1) {
			return null;
		}

		// If the type starts with "array{", it's not nested in a container
		if (arrayShapeStart === 0) {
			return null;
		}

		// Find where the container part ends and array{ begins
		const containerPart = typeStr.substring(0, arrayShapeStart);

		// Check if there's actually a container (should contain < or be a type name followed by <)
		if (!containerPart.includes('<')) {
			return null;
		}

		// Extract the container type (everything before array{)
		// For "list<array{" -> "list"
		// For "array<int, array{" -> "array<int>"
		let containerType = containerPart.trim();
		if (containerType.endsWith('<')) {
			containerType = containerType.slice(0, -1).trim();
		}
		if (containerType.endsWith(',')) {
			// Handle "array<int, array{" case - we want "array<int>"
			const angleStart = containerType.indexOf('<');
			if (angleStart !== -1) {
				containerType = containerType.substring(0, containerType.lastIndexOf(',')).trim() + '>';
			}
		}

		// Extract the nested array shape content
		let depth = 0;
		let i = arrayShapeStart + 5; // Start after "array"
		let inShape = false;

		for (; i < typeStr.length; i++) {
			if (typeStr[i] === '{') {
				depth++;
				inShape = true;
			} else if (typeStr[i] === '}') {
				depth--;
				if (depth === 0) {
					break;
				}
			}
		}

		if (inShape && i < typeStr.length) {
			const nestedContent = typeStr.substring(arrayShapeStart + 6, i);
			return {
				containerType,
				nestedShape: nestedContent
			};
		}

		return null;
	}

	function compareArrayShapes(shape1, shape2) {
		const differences = {};
		const allKeys = new Set([...Object.keys(shape1), ...Object.keys(shape2)]);

		for (const key of allKeys) {
			const type1 = shape1[key];
			const type2 = shape2[key];

			if (type1 === undefined) {
				differences[key] = {
					first: null,
					second: type2
				};
			} else if (type2 === undefined) {
				differences[key] = {
					first: type1,
					second: null
				};
			} else if (type1 !== type2) {
				// Check if both types contain nested array shapes
				const nested1 = extractNestedArrayShape(type1);
				const nested2 = extractNestedArrayShape(type2);

				if (nested1 && nested2) {
					// Both have nested array shapes - compare them
					const nestedShape1 = parseArrayShape(nested1.nestedShape);
					const nestedShape2 = parseArrayShape(nested2.nestedShape);
					const nestedDifferences = compareArrayShapes(nestedShape1, nestedShape2);

					const result = {};

					// Show container type difference if they differ
					if (nested1.containerType !== nested2.containerType) {
						result.containerType = {
							first: nested1.containerType,
							second: nested2.containerType
						};
					}

					// Show nested shape differences
					result.nestedShapeDifferences = nestedDifferences;

					differences[key] = result;
				} else {
					// Simple type difference
					differences[key] = {
						first: type1,
						second: type2
					};
				}
			}
		}

		return differences;
	}

	function findDifferences(input){
	  const shapes = extractArrayShapes(input);

	  if (shapes.length < 2) {
		  outputEl.value = 'Error: Could not find two array{} type definitions in the input.';
		  return;
	  }

	  const shape1 = parseArrayShape(shapes[0]);
	  const shape2 = parseArrayShape(shapes[1]);

	  return compareArrayShapes(shape1, shape2);
  }

	inputEl.addEventListener('input', () => {
		const input = inputEl.value.trim();

		if (!input) {
			outputEl.value = '';
			return;
		}

		try {
		  const differences = findDifferences(input);

			if (Object.keys(differences).length === 0) {
				outputEl.value = '{}';
			} else {
				outputEl.value = JSON.stringify(differences, null, 2);
			}
		} catch (e) {
			outputEl.value = 'Error parsing input: ' + e.message;
		}
	});
</script>
</body>
</html>
